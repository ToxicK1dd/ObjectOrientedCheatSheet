# Principles, Patterns, and Best Practices for Software Development
This comprehensive guide provides a curated collection of essential software development principles, patterns, and best practices.
It covers various aspects of software development, with a focus on object-oriented programming (OOP) and C#. 

Whether you are a beginner or an experienced developer, this resource offers valuable insights to enhance your understanding and skills. \
From fundamental elements to advanced concepts, architecture patterns to project management methodologies, \
this guide aims to equip you with a broad knowledge base and practical guidance for developing high-quality software.

---

### Basic Elements
- [Operators](https://www.tutorialspoint.com/computer_programming/computer_programming_operators.htm)
- [Variables](https://www.tutorialspoint.com/computer_programming/computer_programming_variables.htm)
- [Datatypes](https://www.tutorialspoint.com/computer_programming/computer_programming_data_types.htm)
  - [Value type](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types)
  - [Reference type](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types)
- [Constants](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/const)
- [Arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/)
- [Strings](https://docs.microsoft.com/en-us/dotnet/api/system.string?view=net-5.0)
- [Collections](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/collections)
- [Loops](https://www.tutorialspoint.com/computer_programming/computer_programming_loops.htm)
- [Exceptions](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/)
- [Events](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/)
- [Delegates](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/)
- [Attributes](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/)
- [File I/O](https://docs.microsoft.com/en-us/dotnet/standard/io/)

### General Elements
- [Methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods)
- [Classes](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes)
- [Objects](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/objects)
- [Expressions](https://exceptionnotfound.net/csharp-in-simple-terms-18-expressions-lambdas-and-delegates/)
- [Statements](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements)
- [Conditions](https://www.w3schools.com/CS/cs_conditions.php)

### Fundamentals
- [Sequence](https://www.bbc.co.uk/bitesize/guides/znh6pbk/revision/2)
- [Selection](https://www.bbc.co.uk/bitesize/guides/zh66pbk/revision/3)
- [Iteration](https://www.bbc.co.uk/bitesize/guides/z3khpv4/revision/1)
- [Recursion](https://www.bbc.co.uk/bitesize/guides/z9hykqt/revision/1)

### Declarations
- [Modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)
- [Keywords](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/)
- [Constraints](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters)
- [References](https://stackoverflow.com/questions/40686776/what-exactly-is-a-reference-in-c-sharp)
- [Pointers](https://www.c-sharpcorner.com/article/pointers-in-C-Sharp/)

### Relationships
- [Abstraction](https://www.uml-diagrams.org/abstraction.html)
- [Inheritance](https://stackify.com/oop-concept-inheritance/)
- [Composition](https://www.uml-diagrams.org/composition.html)
- [Association](https://www.uml-diagrams.org/association.html)
- [Aggregation](https://www.uml-diagrams.org/aggregation.html)
- [Generalization](https://www.uml-diagrams.org/generalization.html)
- [Specialization](https://www.indeed.com/career-advice/career-development/generalization-vs-specialization)
- [Dependency](https://www.uml-diagrams.org/dependency.html)
- [Realization](https://www.uml-diagrams.org/realization.html)

### Concepts
- [Encapsulation](https://www.tutorialspoint.com/csharp/csharp_encapsulation.htm)
- [Reflection](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection)
- Polymorphism
  - [Overloading](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/member-overloading)
  - [Overriding](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords)
  -[Generics](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics)
- [Persistence](https://en.m.wikipedia.org/wiki/Persistence_(computer_science))
- [Modularity](https://codewithmukesh.com/blog/modular-architecture-in-aspnet-core/)
- [Decoupling](https://intellitect.com/blog/decoupling-csharp-testable/)
- [Concurrency](https://en.wikipedia.org/wiki/Concurrency_(computer_science))
- [Asynchronous Programming](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/)
- [Parallel Programming](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/)

---

### S.O.L.I.D Design Principles
**SOLID** represents a set of design principles aimed at creating software that is easy to maintain, understand, and extend.\
Each principle focuses on a specific aspect of software design and encourages good coding practices.

- [Single Responsibility Principle](https://dev.to/tamerlang/understanding-solid-principles-single-responsibility-principle-523j)
- [Open/Closed Principle](https://dev.to/tamerlang/understanding-solid-principles-open-closed-principle-5e25)
- [Liskov Substitution Principle](https://dev.to/tamerlang/understanding-solid-principles-liskov-substitution-principle-46an)
- [Interface Segregation](https://dev.to/tamerlang/understanding-solid-principles-interface-separation-32ck)
- [Dependency Inversion Principle](https://dev.to/tamerlang/understanding-solid-principles-dependency-inversion-1b0f)

### CLEAN Design Principles
The CLEAN design principles emphasize writing code that is easy to understand, efficient, and free from redundancy.\
By following these principles, you can enhance the readability, maintainability, and overall quality of your codebase.

- [Clear](#)
- [Logical](#)
- [Effective](#)
- [Accurate](#)
- [Non-redundant](#)

### General Responsibility Assignment Software Patterns ([GRASP](http://www.kamilgrzybek.com/design/grasp-explained/))
**GRASP** (General Responsibility Assignment Software Patterns) is a set of design principles that guide software developers in assigning responsibilities to classes and objects.

These principles help in creating software systems that are modular, maintainable, and adaptable. Each principle focuses on a specific aspect of object-oriented design and promotes good coding practices. The principles include:

 - Information Expert
 - Creator
 - Indirection
 - Low Coupling
 - High Cohesion
 - Polymorphism
 - Protected Variations
 - Pure Fabrication
 - Controller

### Gang of Four ([GOF](https://springframework.guru/gang-of-four-design-patterns/))
The Gang of Four (GoF) design patterns are a collection of 23 design patterns that provide solutions to common software design problems. 

These patterns were defined by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides in their book "Design Patterns: Elements of Reusable Object-Oriented Software". 
The GoF design patterns are divided into three categories:

 - Creational Design Patterns
   - Abstract Factory. Allows the creation of objects without specifying their concrete type.
   - Builder. Uses to create complex objects.
   - Factory Method. Creates objects without specifying the exact class to create.
   - Prototype. Creates a new object from an existing object.
   - Singleton. Ensures only one instance of an object is created.
 - Structural Design Patterns
   - Adapter. Allows for two incompatible classes to work together by wrapping an interface around one of the existing classes.
   - Bridge. Decouples an abstraction so two classes can vary independently.
   - Composite. Takes a group of objects into a single object.
   - Decorator. Allows for an objectâ€™s behavior to be extended dynamically at run time.
   - Facade. Provides a simple interface to a more complex underlying object.
   - Flyweight. Reduces the cost of complex object models.
   - Proxy. Provides a placeholder interface to an underlying object to control access, reduce cost, or reduce complexity.
 - Behavior Design Patterns
   - Chain of Responsibility. Delegates commands to a chain of processing objects.
   - Command. Creates objects which encapsulate actions and parameters.
   - Interpreter. Implements a specialized language.
   - Iterator. Accesses the elements of an object sequentially without exposing its underlying representation.
   - Mediator. Allows loose coupling between classes by being the only class that has detailed knowledge of their methods.
   - Memento. Provides the ability to restore an object to its previous state.
   - Observer. Is a publish/subscribe pattern which allows a number of observer objects to see an event.
   - State. Allows an object to alter its behavior when its internal state changes.
   - Strategy. Allows one of a family of algorithms to be selected on-the-fly at run-time.
   - Template Method. Defines the skeleton of an algorithm as an abstract class, allowing its sub-classes to provide concrete behavior.
   - Visitor. Separates an algorithm from an object structure by moving the hierarchy of methods into one object.
     
---

### Software Development Principles and Guidelines

This section presents a collection of essential principles and guidelines that can guide you in the process of software development.\
These principles encompass various aspects of software design, coding practices, architecture, and project management. 

By adhering to these principles, you can build high-quality software solutions that are modular, maintainable, efficient, and aligned with best practices.\
Explore these principles to enhance your understanding of software development and apply them to your projects for improved outcomes.


- [Separation of Concerns](https://en.m.wikipedia.org/wiki/Separation_of_concerns) (Dividing software into distinct sections addressing specific responsibilities.)
- [Inversion of Control](https://en.m.wikipedia.org/wiki/Inversion_of_control) (Delegating control flow and object creation to a central entity.)
- [SLAP](https://dzone.com/articles/slap-your-methods-and-dont-make-me-think) (Single Level of Abstraction Principle)
- [LBYL](https://realpython.com/python-lbyl-vs-eafp/) (Look Before You Leap)
- [EAFP](https://realpython.com/python-lbyl-vs-eafp/) (Easier to Ask Forgiveness than Permission)
- [DRY](https://thevaluable.dev/dry-principle-cost-benefit-example/) (Don't Repeat Yourself)
- [WET](https://betterprogramming.pub/when-dry-doesnt-work-go-wet-6befda0444bf) (Write Everything Twice)
- [AHA](https://kentcdodds.com/blog/aha-programming) (Avoid Hasty Abstractions)
- [KISS](https://www.freecodecamp.org/news/keep-it-simple-stupid-how-to-use-the-kiss-principle-in-design/) (Keep It Simple, Stupid)
- [YAGNI](https://martinfowler.com/bliki/Yagni.html) (You Aren't Gonna Need It)
- [RTFM](https://www.computerhope.com/jargon/r/rtfm.htm) (Read The Fucking Manual)
- [JFGI](https://www.urbandictionary.com/define.php?term=jfgi) (Just Fucking Google It) *// not really a principle*
- [ACID](https://www.ibm.com/docs/en/cics-ts/5.4?topic=processing-acid-properties-transactions) (Atomicity, Consistency, Isolation, Durability)
- [PLOD](https://stackify.com/premature-optimization-evil/) (Premature Lateral Optimization Disorder) *// not really a principle*
- [FIFO](https://www.geeksforgeeks.org/fifo-first-in-first-out-approach-in-programming/) (First In, First Out)
- [LIFO](https://www.geeksforgeeks.org/fifo-vs-lifo-approach-in-programming/) (Last In, First Out)
  
These principles and guidelines provide valuable insights and best practices for software development. By incorporating them into your development process, you can enhance the quality and effectiveness of your software solutions. Here are some key benefits of following these principles:

1. **Modularity**: *Emphasizing modularity helps in breaking down complex systems into smaller, manageable components. This promotes better organization, reusability, and easier maintenance of code.*

2. **Simplicity**: *Striving for simplicity in design and implementation leads to code that is **easier to understand** and reason about. Simple code reduces complexity and improves readability, which facilitates collaboration and makes it easier for other developers to work with your code.*

3. **Maintainability**: *By following best practices, such as adhering to coding standards, writing clean and self-explanatory code, and applying proper documentation, you enhance the maintainability of your software. This makes it **easier to identify and fix issues**, update functionality, and adapt to changing requirements.*

4. **Efficient Problem-Solving**: *These principles encourage effective problem-solving by promoting sound architectural and design choices. They help you identify potential pitfalls, mitigate risks, and make **informed decisions** during the development process.*

By incorporating these principles into your development workflow, you foster a mindset of creating high-quality software that is **easier to maintain, update, and understand**. This ultimately leads to **faster development cycles**, improved collaboration among team members, and increased satisfaction for both developers and end-users.

Remember, while these principles provide valuable guidance, it's essential to apply them **judiciously**, considering the specific context and requirements of your project.

---

### Common Anti-Patterns and Code Smells

Anti-patterns and code smells are common issues found in software development that can lead to negative consequences,\
and hinder the quality and maintainability of a codebase.

Recognizing and addressing these anti-patterns, and code smells is crucial for building better software systems,\
and improving the overall quality of the codebase.


| Anti-Pattern / Code Smell   | Type         | Explanation |
|-----------------------------|--------------|-------------|
| Anemic Domain Model         | Anti-Pattern | Occurs when the domain objects lack behavior and are primarily used as data containers, resulting in business logic being spread across multiple classes. |
| Boat Anchor                 | Anti-Pattern | Describes a piece of code or functionality that is no longer needed or used but remains in the codebase, adding unnecessary complexity and maintenance overhead. |
| Code Duplication            | Code Smell   | The presence of redundant or repeated code blocks, indicating a need for refactoring to improve code maintainability and reduce the risk of inconsistencies. |
| Dead Code                   | Code Smell   | Refers to code that is no longer executed or reachable during program execution, usually due to refactoring, changes in requirements, or developer oversight. |
| Dead Comments               | Code Smell   | Inactive or obsolete comments that no longer provide relevant information or clarification, cluttering the codebase. |
| Feature Envy                | Code Smell   | Occurs when a class or method excessively relies on the data or behavior of another class, indicating a potential design flaw. |
| God Objects                 | Anti-Pattern | Represents a class or module that has excessive responsibilities and knows too much about other parts of the system, leading to low cohesion and difficult maintenance. |
| Golden Hammer               | Anti-Pattern | Refers to the tendency to overuse a familiar tool or technology, even when it is not the most suitable or effective solution for the given problem. |
| Inappropriate Intimacy      | Code Smell   | Describes a situation where two classes are tightly coupled and overly dependent on each other, leading to reduced maintainability and flexibility. |
| Inner-Platform Effect       | Anti-Pattern | Refers to the phenomenon where developers build custom abstractions or frameworks that replicate the functionality of existing mature platforms, leading to increased complexity and maintenance burden. |
| Large Class                 | Code Smell   | Indicates a class that has grown too large, potentially violating the Single Responsibility Principle and making the code harder to understand and maintain. |
| Magic Numbers/Strings       | Code Smell   | Refers to the usage of hard-coded numerical or string literals without proper explanation or abstraction, reducing code readability and maintainability. |
| Message Chains              | Code Smell   | Involves a series of method calls on different objects, indicating a potential violation of the Law of Demeter and increasing coupling between classes. |
| Middle Man                  | Anti-Pattern | Refers to a class that serves as an unnecessary intermediary between two components, adding unnecessary indirection and complexity to the codebase. |
| Primitive Obsession         | Code Smell   | Occurs when primitive data types are used excessively instead of creating proper abstractions or domain-specific classes, leading to less expressive code. |
| Shotgun Surgery             | Anti-Pattern | Occurs when a single change to the system requires making numerous small modifications across different classes or modules, resulting in fragile code. |
| Speculative Generality      | Anti-Pattern | Occurs when code is designed to be overly flexible or generic to accommodate potential future requirements that may never arise, resulting in unnecessary complexity. |
| Spaghetti Code              | Code Smell   | Describes code that is tangled and difficult to understand, typically due to excessive and uncontrolled branching, lack of proper structure, and poor naming. |

### Explanations

- **Anti-Patterns**: *Anti-patterns refer to common practices or solutions in software development that appear to be beneficial but ultimately lead to negative consequences. They are typically patterns of behavior, architecture, or design that are counterproductive and can hinder the development process, introduce complexity, reduce maintainability, or increase the likelihood of errors. Recognizing and avoiding anti-patterns helps developers build better software systems.*

- **Code Smells**: *Code smells are indicators or symptoms in code that suggest potential design or implementation issues. They are specific characteristics or patterns in the codebase that may not necessarily be incorrect but could indicate areas that could be improved for better maintainability, readability, or extensibility. Code smells are usually subjective and rely on experienced developers' judgment to identify potential problem areas and apply appropriate refactoring techniques.*

Both anti-patterns and code smells serve as warning signs that highlight areas in software development where improvements can be made. By understanding and addressing these issues, developers can strive for cleaner, more maintainable codebases and avoid common pitfalls in software development.

### Goals of Avoiding Code Smells and Anti-Patterns

The primary goals of identifying and addressing code smells and anti-patterns in software development are to improve the codebase's maintainability, understandability, and performance. By actively avoiding these issues, developers can achieve the following:

1. **Enhance Maintainability**: *Code smells and anti-patterns often indicate areas of the codebase that are difficult to maintain. By eliminating or refactoring these problematic patterns, developers can make the codebase more modular, organized, and easier to modify. This results in a codebase that can be more readily adapted to new requirements or changes without introducing bugs or unforeseen side effects.*

2. **Improve Understandability**: *Code that is clean, well-structured, and free from smells and anti-patterns is easier to understand. Clear and concise code allows developers to comprehend the functionality and purpose of different components, classes, and methods more easily. This improves collaboration among team members, reduces the time spent on deciphering complex logic, and promotes better communication within the development team.*

3. **Increase Development Speed**: *A codebase free from code smells and anti-patterns enables developers to work more efficiently. By avoiding redundant code, complex logic, and unnecessary abstractions, developers can spend less time troubleshooting and more time delivering new features and resolving customer issues. This leads to faster development cycles, quicker bug fixes, and improved overall productivity.*

4. **Enhance Performance**: *Code smells and anti-patterns can have a negative impact on the performance of the software. Redundant code, excessive resource consumption, and inefficient algorithms can lead to decreased execution speed and increased memory usage. By addressing these issues, developers can optimize the codebase, resulting in improved performance and a more responsive application.*

5. **Foster Scalability and Extensibility**: *A codebase free from code smells and anti-patterns is more scalable and extensible. Clean code makes it easier to add new features, modify existing functionalities, and integrate with other systems. It enables developers to build upon a solid foundation and maintain a flexible architecture that can evolve as the software requirements change over time.*

By striving to avoid code smells and anti-patterns, developers create a more maintainable, understandable, and performant codebase. This not only benefits the development team but also improves the overall quality of the software product, leading to higher customer satisfaction and long-term success.

---

### Data Structures & Algorithms
 - Levenshtein distance algorithm 

### Programming Models
 - Object Oriented Programming (OOP)
 - Functional Programming
 
### Architectural Patterns
 - Model-View-ViewModel (MVVM)
 - Model-View-Controller (MVC)
 - Model-View-Presenter (MVP)

### API Architectural Patterns
 - GraphQL
 - Representational State Transfer (REST)
 - Remote Procedure Call (gRPC)
 - Simple Object Access Protocol (SOAP)

### Development Process
 - Test Driven Development (TDD)
 - Behavior Driven Development (BDD)
 - Domain Driven Development (DDD)
 - [Responsibility Driven Design](https://www.wirfs-brock.com/PDFs/A_Brief-Tour-of-RDD.pdf) 
 - Clean Architecture

---

### Project Management
 - Agile Model
   - Scrum
     - [Stakeholder Management](https://www.scrum.org/resources/blog/10-tips-product-owners-stakeholder-management)
     - [Risk Management](https://www.scrum.org/resources/blog/managing-risk-scrum)
   - Kanban
     - Visualize Workflow 
     - Limit Work in Progress (WIP) 
     - Focus on Flow
     - Continuous Improvement
   - [Extreme Programming](https://www.agilealliance.org/glossary/xp/)
 - Waterfall Model
 - [Salience Model](https://pmstudycircle.com/salience-model-to-analyze-project-stakeholders/)

### [User Stories](https://xp123.com/articles/invest-in-good-stories-and-smart-tasks/)
 - INVEST
   - Independent
   - Negotiable
   - Valuable
   - Estimable
   - Small
   - Testable
 - SMART
   - Specific
   - Measurable
   - Achievable
   - Relevant
   - Time-boxed 

### Design Pattern:
 - Creational
 - Behavioral
 - Structural 

### Best Practices
 - Pascal casing, camel casing
 - Folder/Project structure
 - Triple A (UnitTesting)

### Buzzwords <sub><sup><sup>kinda makes me sound cool</sup></sup></sub>
 - Artificial Intelligence (AI)
 - Machine Learning (ML)
 - Optical Character Recognition (OCR)
 - Non-Fungible Token (NFT)
 - Big Data
 - Blockchain
 - Metaverse
 - Microservices

### Advice
 - [Make it work, Make it Right, Make it fast](https://betterprogramming.pub/the-principles-of-software-development-7415e7c5a156)

### Useful Resources
 - [Refactoring Guru](https://refactoring.guru/)
 - [Martin Fowler](https://martinfowler.com/)
 - [Uncle Bob](http://cleancoder.com/products)
 - [Try QA](http://tryqa.com/)
 - [Scrum Guides](https://scrumguides.org/)

### Articles & Blogs
 - [Saying No to Stakeholders](https://www.mountaingoatsoftware.com/blog/six-guidelines-for-saying-no-to-a-stakeholder)
 - [Stakeholder Management](https://www.pmi.org/learning/library/stakeholder-management-task-project-success-7736)
 - [10 Principles of Stakeholder Engagement](https://www.henricodolfing.com/2018/03/10-principles-of-stakeholder-engagement.html)
 - [10 Tips for Product Owners](https://www.scrum.org/resources/blog/10-tips-product-owners-stakeholder-management)

### Misc
 - Line of Business
 - Business Domain

<!-- Written and Directed by ToxicK1dd - https://baek.pro/ -->
